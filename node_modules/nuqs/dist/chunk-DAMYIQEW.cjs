'use strict';

var chunkKNSPBEHI_cjs = require('./chunk-KNSPBEHI.cjs');
var react = require('react');

var $input = Symbol("Input");
function createSearchParamsCache(parsers) {
  const getCache = react.cache(() => ({
    searchParams: {}
  }));
  function parseSync(searchParams) {
    const c = getCache();
    if (Object.isFrozen(c.searchParams)) {
      if (c[$input] && compareSearchParams(searchParams, c[$input])) {
        return all();
      }
      throw new Error(chunkKNSPBEHI_cjs.error(501));
    }
    for (const key in parsers) {
      const parser = parsers[key];
      c.searchParams[key] = parser.parseServerSide(searchParams[key]);
    }
    c[$input] = searchParams;
    return Object.freeze(c.searchParams);
  }
  function parse(searchParams) {
    if (searchParams instanceof Promise) {
      return searchParams.then(parseSync);
    }
    return parseSync(searchParams);
  }
  function all() {
    const { searchParams } = getCache();
    if (Object.keys(searchParams).length === 0) {
      throw new Error(chunkKNSPBEHI_cjs.error(500));
    }
    return searchParams;
  }
  function get(key) {
    const { searchParams } = getCache();
    const entry = searchParams[key];
    if (typeof entry === "undefined") {
      throw new Error(
        chunkKNSPBEHI_cjs.error(500) + `
  in get(${String(key)})`
      );
    }
    return entry;
  }
  return { parse, get, all };
}
function compareSearchParams(a, b) {
  if (a === b) {
    return true;
  }
  if (Object.keys(a).length !== Object.keys(b).length) {
    return false;
  }
  for (const key in a) {
    if (a[key] !== b[key]) {
      return false;
    }
  }
  return true;
}

exports.compareSearchParams = compareSearchParams;
exports.createSearchParamsCache = createSearchParamsCache;
