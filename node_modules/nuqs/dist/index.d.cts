import { P as Parser, a as ParserBuilder, p as parseAsStringEnum, b as parseAsJson, c as parseAsArrayOf, O as Options, N as Nullable } from './serializer-DjSGvhZt.cjs';
export { H as HistoryOptions, e as createParser, d as createSerializer, o as inferParserType, j as parseAsBoolean, i as parseAsFloat, h as parseAsHex, g as parseAsInteger, l as parseAsIsoDateTime, n as parseAsNumberLiteral, f as parseAsString, m as parseAsStringLiteral, k as parseAsTimestamp } from './serializer-DjSGvhZt.cjs';
import 'react';

/**
 * @deprecated renamed to Parser
 */
type Serializers<T> = Parser<T>;
/**
 * @deprecated renamed to ParserBuilder.
 * You should probably use `createParser` instead.
 */
type SerializersWithDefaultFactory<T> = ParserBuilder<T>;
/**
 * @deprecated use individual `parseAsXyz` imports instead.
 */
declare const queryTypes: {
    /**
     * @deprecated use `parseAsString` instead.
     */
    readonly string: ParserBuilder<string>;
    /**
     * @deprecated use `parseAsInteger` instead.
     */
    readonly integer: ParserBuilder<number>;
    /**
     * @deprecated use `parseAsFloat` instead.
     */
    readonly float: ParserBuilder<number>;
    /**
     * @deprecated use `parseAsBoolean` instead.
     */
    readonly boolean: ParserBuilder<boolean>;
    /**
     * @deprecated use `parseAsTimestamp` instead.
     */
    readonly timestamp: ParserBuilder<Date>;
    /**
     * @deprecated use `parseAsIsoDateTime` instead.
     */
    readonly isoDateTime: ParserBuilder<Date>;
    /**
     * @deprecated use `parseAsStringEnum` instead.
     */
    readonly stringEnum: typeof parseAsStringEnum;
    /**
     * @deprecated use `parseAsJson` instead.
     */
    readonly json: typeof parseAsJson;
    /**
     * @deprecated use `parseAsArrayOf` instead.
     */
    readonly array: typeof parseAsArrayOf;
};
/**
 * @deprecated use individual `parseAsXyz` imports instead
 */
type QueryTypeMap = typeof queryTypes;

type QueryUpdateSource = 'internal' | 'external';
type QueryUpdateNotificationArgs = {
    search: URLSearchParams;
    source: QueryUpdateSource;
};
declare global {
    interface History {
        __nuqs_patched?: string;
    }
}
/**
 * @deprecated Since Next.js introduced shallow routing in 14.0.3, this
 * method is no longer needed as you can use `useSearchParams`, which will
 * react to changes in the URL when the `windowHistorySupport` experimental flag
 * is set.
 * This method will be removed in `nuqs@2.0.0`, when Next.js
 * decides to land the `windowHistorySupport` flag in GA.
 */
declare function subscribeToQueryUpdates(callback: (args: QueryUpdateNotificationArgs) => void): () => void;

interface UseQueryStateOptions<T> extends Parser<T>, Options {
}
type UseQueryStateReturn<Parsed, Default> = [
    Default extends undefined ? Parsed | null : Parsed,
    <Shallow>(value: null | Parsed | ((old: Default extends Parsed ? Parsed : Parsed | null) => Parsed | null), options?: Options<Shallow>) => Promise<URLSearchParams>
];
/**
 * React state hook synchronized with a URL query string in Next.js
 *
 * This variant is used when providing a default value. This will make
 * the returned state non-nullable when the query is not present in the URL.
 * (the default value will be returned instead).
 *
 * _Note: the URL will **not** be updated with the default value if the query
 * is missing._
 *
 * Setting the value to `null` will clear the query in the URL, and return
 * the default value as state.
 *
 * Example usage:
 * ```ts
 *   const [count, setCount] = useQueryState(
 *     'count',
 *     queryTypes.integer.defaultValue(0)
 *   )
 *
 *   const increment = () => setCount(oldCount => oldCount + 1)
 *   const decrement = () => setCount(oldCount => oldCount - 1)
 *   // Clears the query key from the URL and `count` equals 0
 *   const clearCountQuery = () => setCount(null)
 * ```
 * @param key The URL query string key to bind to
 * @param options - Parser (defines the state data type), default value and optional history mode.
 */
declare function useQueryState<T>(key: string, options: UseQueryStateOptions<T> & {
    defaultValue: T;
}): UseQueryStateReturn<NonNullable<ReturnType<typeof options.parse>>, typeof options.defaultValue>;
/**
 * React state hook synchronized with a URL query string in Next.js
 *
 * If the query is missing in the URL, the state will be `null`.
 *
 * Example usage:
 * ```ts
 *   // Blog posts filtering by tag
 *   const [tag, selectTag] = useQueryState('tag')
 *   const filteredPosts = posts.filter(post => tag ? post.tag === tag : true)
 *   const clearTag = () => selectTag(null)
 * ```
 * @param key The URL query string key to bind to
 * @param options - Parser (defines the state data type), and optional history mode.
 */
declare function useQueryState<T>(key: string, options: UseQueryStateOptions<T>): UseQueryStateReturn<NonNullable<ReturnType<typeof options.parse>>, undefined>;
/**
 * Default type string, limited options & default value
 */
declare function useQueryState(key: string, options: Options & {
    defaultValue: string;
}): UseQueryStateReturn<string, typeof options.defaultValue>;
/**
 * React state hook synchronized with a URL query string in Next.js
 *
 * If the query is missing in the URL, the state will be `null`.
 *
 * Note: by default the state type is a `string`. To use different types,
 * check out the `queryTypes` helpers:
 * ```ts
 *   const [date, setDate] = useQueryState(
 *     'date',
 *     queryTypes.isoDateTime.withDefault(new Date('2021-01-01'))
 *   )
 *
 *   const setToNow = () => setDate(new Date())
 *   const addOneHour = () => {
 *     setDate(oldDate => new Date(oldDate.valueOf() + 3600_000))
 *   }
 * ```
 * @param key The URL query string key to bind to
 * @param options - Parser (defines the state data type), and optional history mode.
 */
declare function useQueryState(key: string, options: Pick<UseQueryStateOptions<string>, keyof Options>): UseQueryStateReturn<string, undefined>;
/**
 * React state hook synchronized with a URL query string in Next.js
 *
 * If the query is missing in the URL, the state will be `null`.
 *
 * Note: by default the state type is a `string`. To use different types,
 * check out the `queryTypes` helpers:
 * ```ts
 *   const [date, setDate] = useQueryState(
 *     'date',
 *     queryTypes.isoDateTime.withDefault(new Date('2021-01-01'))
 *   )
 *
 *   const setToNow = () => setDate(new Date())
 *   const addOneHour = () => {
 *     setDate(oldDate => new Date(oldDate.valueOf() + 3600_000))
 *   }
 * ```
 * @param key The URL query string key to bind to
 */
declare function useQueryState(key: string): UseQueryStateReturn<string, undefined>;

type KeyMapValue<Type> = Parser<Type> & Options & {
    defaultValue?: Type;
};
type UseQueryStatesKeysMap<Map = any> = {
    [Key in keyof Map]: KeyMapValue<Map[Key]>;
};
interface UseQueryStatesOptions extends Options {
}
type Values<T extends UseQueryStatesKeysMap> = {
    [K in keyof T]: T[K]['defaultValue'] extends NonNullable<ReturnType<T[K]['parse']>> ? NonNullable<ReturnType<T[K]['parse']>> : ReturnType<T[K]['parse']> | null;
};
type UpdaterFn<T extends UseQueryStatesKeysMap> = (old: Values<T>) => Partial<Nullable<Values<T>>>;
type SetValues<T extends UseQueryStatesKeysMap> = (values: Partial<Nullable<Values<T>>> | UpdaterFn<T> | null, options?: Options) => Promise<URLSearchParams>;
type UseQueryStatesReturn<T extends UseQueryStatesKeysMap> = [
    Values<T>,
    SetValues<T>
];
/**
 * Synchronise multiple query string arguments to React state in Next.js
 *
 * @param keys - An object describing the keys to synchronise and how to
 *               serialise and parse them.
 *               Use `queryTypes.(string|integer|float)` for quick shorthands.
 * @param options - Optional history mode, shallow routing and scroll restoration options.
 */
declare function useQueryStates<KeyMap extends UseQueryStatesKeysMap>(keyMap: KeyMap, { history, scroll, shallow, throttleMs, clearOnDefault, startTransition, urlKeys }?: Partial<UseQueryStatesOptions & {
    urlKeys: Partial<Record<keyof KeyMap, string>>;
}>): UseQueryStatesReturn<KeyMap>;

export { Options, Parser, ParserBuilder, type QueryTypeMap, type QueryUpdateNotificationArgs, type QueryUpdateSource, type Serializers, type SerializersWithDefaultFactory, type SetValues, type UseQueryStateOptions, type UseQueryStateReturn, type UseQueryStatesKeysMap, type UseQueryStatesOptions, type UseQueryStatesReturn, type Values, parseAsArrayOf, parseAsJson, parseAsStringEnum, queryTypes, subscribeToQueryUpdates, useQueryState, useQueryStates };
